<!-- Simple Audio Player -->
<div class="audio-player">
  <div id="now-playing"></div>
  <audio id="audio-player" controls></audio>
  <div class="player-controls">
    <button id="prev-button" class="button">⏮</button>
    <button id="shuffle-button" class="button">shuffle</button>
    <button id="next-button" class="button">⏭</button>
  </div>
</div>

<div id="playlist"></div>

<div id="queue"></div>


<script>
document.addEventListener('DOMContentLoaded', () => {
  // DOM Elements
  const audioElement = document.getElementById('audio-player');
  const nowPlayingElement = document.getElementById('now-playing');
  const playlistElement = document.getElementById('playlist');
  const shuffleBtn = document.getElementById('shuffle-button');
  const prevBtn = document.getElementById('prev-button');
  const nextBtn = document.getElementById('next-button');
  
  // State
  let tracks = [];
  let tracksById = {};
  let currentIndex = -1;
  let shuffleMode = false;
  let playHistory = [];     // Array to store play history
  let historyIndex = -1;    // Current position in history
  let trackElements = [];
  let lastPositionUpdate = 0;
  
  // Initialize the player
  init();
  
  async function init() {
    try {
      const data = await fetch('/assets/data/tracks.json').then(r => r.json());
      processData(data);
      setupUI(data);
      setupEvents();
    } catch (error) {
      console.error('Player error:', error);
      playlistElement.innerHTML = '<p>Failed to load music.</p>';
    }
  }
  
  function processData(data) {
    tracks = [];
    tracksById = {};
    
    Object.entries(data).forEach(([genre, genreTracks]) => {
      genreTracks.forEach(track => {
        if (!track || !track.id || !track.title) return;
        
        const trackWithGenre = { genre, id: track.id, title: track.title };
        tracks.push(trackWithGenre);
        tracksById[track.id] = trackWithGenre;
      });
    });
  }
  
  function setupUI(data) {
    playlistElement.innerHTML = '';
    trackElements = [];
    
    Object.entries(data).forEach(([genre, genreTracks]) => {
      const details = document.createElement('details');
      details.className = 'genre-section';
      details.open = false;
      
      const summary = document.createElement('summary');
      summary.textContent = genre;
      details.appendChild(summary);
      
      const tracksList = document.createElement('ul');
      tracksList.className = 'track-list';
      
      genreTracks.forEach(track => {
        if (!track || !track.id || !track.title) return;
        
        const li = document.createElement('li');
        li.textContent = track.title;
        li.className = 'track';
        li.dataset.id = track.id;
        li.dataset.genre = genre;
        
        const handleTrackClick = () => playById(track.id);
        li.addEventListener('click', handleTrackClick);
        
        // Store reference to element and handler for cleanup
        trackElements.push({ 
          element: li, 
          handler: handleTrackClick,
          id: track.id
        });
        
        tracksList.appendChild(li);
      });
      
      details.appendChild(tracksList);
      playlistElement.appendChild(details);
    });
  }
  
  function setupEvents() {
    // Audio event listeners
    audioElement.addEventListener('ended', handleTrackEnd);
    audioElement.addEventListener('error', handleError);
    audioElement.addEventListener('pause', handlePause);
    audioElement.addEventListener('play', handlePlay);
    audioElement.addEventListener('timeupdate', handleTimeUpdate);
    audioElement.addEventListener('durationchange', handleDurationChange);
    
    // Button event listeners
    shuffleBtn.addEventListener('click', toggleShuffle);
    prevBtn.addEventListener('click', playPrev);
    nextBtn.addEventListener('click', playNext);
    
    // Window event listener for cleanup
    window.addEventListener('beforeunload', cleanup);
  }
  
  function playById(id) {
    const index = tracks.findIndex(t => t.id === id);
    if (index !== -1) {
      currentIndex = index;
      
      // When directly selecting a track, clear future history
      if (historyIndex < playHistory.length - 1) {
        playHistory = playHistory.slice(0, historyIndex + 1);
      }
      
      // Add to history and update index
      playHistory.push(index);
      historyIndex = playHistory.length - 1;
      
      loadTrack();
    }
  }
  
  function loadTrack() {
    const track = tracks[currentIndex];
    if (!track) return;
    
    // Update active track in UI
    document.querySelectorAll('.track.active').forEach(t => t.classList.remove('active'));
    const trackEl = document.querySelector(`.track[data-id="${track.id}"]`);
    if (trackEl) {
      trackEl.classList.add('active');
      const parentDetails = trackEl.closest('details');
      if (parentDetails) parentDetails.open = true;
    }
    
    // Load and play the track
    const fileName = encodeURIComponent(track.title + '.mp3');
    const path = `/assets/static/music/${track.genre.toLowerCase()}/${fileName}`;
    
    nowPlayingElement.textContent = track.title;
    audioElement.src = path;    
    audioElement.play().then(() => {
    }).catch(error => {
      console.error('Error playing track:', error);
      handleError();
    });
  }
  
  function updateMediaSession(trackTitle) {
    if (!('mediaSession' in navigator)) return;
    
    const artworkPath = window.location.origin + '/assets/static/mw.jpeg';
    
    navigator.mediaSession.metadata = new MediaMetadata({
      title: trackTitle,
      artist: '', 
      album: '', 
      artwork: [
        { src: artworkPath, sizes: '512x512', type: 'image/jpeg' }
      ] 
    });
    
    // Set up media session actions with direct function references
    try {
      navigator.mediaSession.setActionHandler('previoustrack', playPrev);
      navigator.mediaSession.setActionHandler('nexttrack', playNext);
      navigator.mediaSession.setActionHandler('play', () => audioElement.play());
      navigator.mediaSession.setActionHandler('pause', () => audioElement.pause());
      
      // Add seek handler for compatible browsers
      if ('setActionHandler' in navigator.mediaSession && 'seekto' in MediaSessionAction) {
        navigator.mediaSession.setActionHandler('seekto', (details) => {
          if (details.fastSeek && 'fastSeek' in audioElement) {
            audioElement.fastSeek(details.seekTime);
            return;
          }
          audioElement.currentTime = details.seekTime;
          updatePositionState(); // Update immediately after seeking
        });
      }
    } catch (e) {
      console.error('Error setting media session handlers:', e);
    }
    
    updatePositionState();
  }

  // Update position state for lock screen
  function updatePositionState() {
    if (!('mediaSession' in navigator)) return;
    
    // Additional check for iOS - it might not support setPositionState
    if (!('setPositionState' in navigator.mediaSession)) return;
    
    if (isNaN(audioElement.duration) || audioElement.duration <= 0) return;
    
    try {
      navigator.mediaSession.setPositionState({
        duration: audioElement.duration || 0,
        playbackRate: audioElement.playbackRate || 1,
        position: audioElement.currentTime || 0
      });
    } catch (e) {
      console.error('Error updating position state:', e);
    }
  }
  
  // Event handlers
  function handleTrackEnd() {
    playNext();
  }
  
  function handleError() {
    nowPlayingElement.textContent = 'Error playing track';
    setTimeout(() => playNext(), 500);
  }
  
  function handlePause() {
    updateMediaSession(tracks[currentIndex].title);
  }
  
  function handlePlay() {
    updateMediaSession(tracks[currentIndex].title);
  }
  
  function handleTimeUpdate() {
    // Update position state more frequently (reduce throttle time for iOS)
    if (lastPositionUpdate && Date.now() - lastPositionUpdate < 1000) return;
    lastPositionUpdate = Date.now();
    updatePositionState();
  }
  
  function handleDurationChange() {
    updatePositionState();
  }
  
  function playNext() {
    if (!tracks.length) return;
    
    // Check if we're already navigating through history
    if (historyIndex < playHistory.length - 1) {
      // Move forward in history
      historyIndex++;
      currentIndex = playHistory[historyIndex];
      loadTrack();
      return;
    }
    
    // Otherwise play the next track normally
    let nextIndex;
    if (shuffleMode) {
      // Random track in shuffle mode
      nextIndex = Math.floor(Math.random() * tracks.length);
      // Avoid playing the same track twice
      if (nextIndex === currentIndex && tracks.length > 1) {
        nextIndex = (nextIndex + 1) % tracks.length;
      }
    } else {
      // Next track in sequence
      nextIndex = (currentIndex + 1) % tracks.length;
    }
    
    // Update current index and add to history
    currentIndex = nextIndex;
    playHistory.push(nextIndex);
    historyIndex = playHistory.length - 1;
    
    loadTrack();
  }
  
  function playPrev() {
    if (!tracks.length) return;
    
    // If we have history and not at the beginning
    if (historyIndex > 0) {
      historyIndex--;
      currentIndex = playHistory[historyIndex];
      loadTrack();
      return;
    }
    
    // If at the start of history or no history, use the default behavior
    currentIndex = (currentIndex - 1 + tracks.length) % tracks.length;
    
    // Add to history since we're going to a new track not in history
    playHistory.push(currentIndex);
    historyIndex = playHistory.length - 1;
    
    loadTrack();
  }
  
  function toggleShuffle() {
    shuffleMode = !shuffleMode;
    shuffleBtn.classList.toggle('active', shuffleMode);
    shuffleBtn.setAttribute('aria-pressed', shuffleMode);
    
    // Auto-start playback if paused and shuffle enabled
    if (shuffleMode && audioElement.paused && tracks.length > 0) {
      playNext();
    }
  }
  
  function cleanup() {
    // Clean up media session handlers
    if ('mediaSession' in navigator) {
      navigator.mediaSession.setActionHandler('previoustrack', null);
      navigator.mediaSession.setActionHandler('nexttrack', null);
      navigator.mediaSession.setActionHandler('play', null);
      navigator.mediaSession.setActionHandler('pause', null);
      navigator.mediaSession.setActionHandler('seekto', null);
    }
    
    // Remove all audio event listeners
    audioElement.removeEventListener('ended', handleTrackEnd);
    audioElement.removeEventListener('error', handleError);
    audioElement.removeEventListener('pause', handlePause);
    audioElement.removeEventListener('play', handlePlay);
    audioElement.removeEventListener('timeupdate', handleTimeUpdate);
    audioElement.removeEventListener('durationchange', handleDurationChange);
    
    // Remove all button event listeners
    shuffleBtn.removeEventListener('click', toggleShuffle);
    prevBtn.removeEventListener('click', playPrev);
    nextBtn.removeEventListener('click', playNext);
    
    // Remove event listeners from track elements
    trackElements.forEach(item => {
      item.element.removeEventListener('click', item.handler);
    });
    
    // Remove window event listener
    window.removeEventListener('beforeunload', cleanup);
  }
});
</script>

<style>
  .audio-player {
    position: sticky;
    top: 0;
    font-size: 0.9rem;
    display: flex;
    flex-direction: column;
    align-items: stretch;
    z-index: 10;
  }

  #audio-player {
    width: 100%;
  }
  
  #now-playing {
    font-family: "Atkinson Hyperlegible Mono", "Inconsolata", monospace;
    padding-top: 0.5rem;
    padding-bottom: 0.5rem;
    margin-left: 1rem;
    background-color: #1b1c1d;
  }

  .player-controls {
    display: flex;
    justify-content: right;
  }
  
  .player-controls button {
    background-color: #1b1c1d;
    font-family: "Atkinson Hyperlegible Mono", "Inconsolata", monospace;  
    cursor: pointer;
    border: none;
    font-size: 0.9rem;
  }
  
  #shuffle-button.active {
    color: #FF530D;
  }

  .track {
    cursor: pointer;
  }
  
  .track:hover {
    text-decoration: underline;
  }
  
  .track.active {
    color: #FF530D;
  }
  
  .track-list {
    margin-bottom: 1rem;
  }
</style>