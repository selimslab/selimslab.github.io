<!-- Simple Audio Player -->
<div class="audio-player">
  <div id="now-playing"></div>
  <audio id="audio-player" controls></audio>
  <div class="player-controls">
    <button id="prev-button" class="button">⏮</button>
    <button id="shuffle-button" class="button">shuffle</button>
    <button id="next-button" class="button">⏭</button>
  </div>
</div>

<div id="playlist"></div>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const audioElement = document.getElementById('audio-player');
    const nowPlayingElement = document.getElementById('now-playing');
    const playlistElement = document.getElementById('playlist');
    const shuffleBtn = document.getElementById('shuffle-button');
    const prevBtn = document.getElementById('prev-button');
    const nextBtn = document.getElementById('next-button');

    let tracks = [];
    let currentIndex = -1
    let shuffleMode = false;
    let playHistory = [];
    let historyPosition = -1;
    let lastUpdatedSecondForPosition = -1; // To track position updates
    let mediaSessionInitialized = false; // Flag to track MediaSession initialization

    // Initialize MediaSession as early as possible
    initializeMediaSession();

    // Load tracks and setup player
    fetch('/assets/data/tracks.json')
      .then(response => response.json())
      .then(data => {
        setupPlayer(data);
      })
      .catch(error => {
        console.error('Player error:', error);
        playlistElement.innerHTML = '<p>Failed to load music.</p>';
      });

    function setupPlayer(data) {
      // Process tracks
      tracks = [];
      Object.entries(data).forEach(([genre, genreTracks]) => {
        genreTracks.forEach(track => {
          if (track?.id && track?.title) {
            tracks.push({ genre, id: track.id, title: track.title });
          }
        });
      });

      // Build UI
      buildPlaylist(data);
      
      // Setup event listeners
      audioElement.addEventListener('ended', () => playTrack('next'));
      
      // Ensure MediaSession state directly tracks audio element state
      audioElement.addEventListener('play', () => {
        updateMediaSessionPlaybackState('playing');
        // Force position update on play
        lastUpdatedSecondForPosition = -1;
        updateMediaSessionPositionState();
      });
      
      audioElement.addEventListener('pause', () => {
        updateMediaSessionPlaybackState('paused');
        // Force position update on pause
        updateMediaSessionPositionState();
      });
      
      // Ensure MediaSession is properly initialized
      if (!mediaSessionInitialized) {
        initializeMediaSession();
      }
      
      shuffleBtn.addEventListener('click', () => {
        shuffleMode = !shuffleMode;
        shuffleBtn.classList.toggle('active', shuffleMode);
        
        // Auto-start playback if paused and shuffle enabled
        if (shuffleMode && audioElement.paused && tracks.length > 0) {
          playTrack('next');
        }
      });
      
      prevBtn.addEventListener('click', () => playTrack('prev'));
      nextBtn.addEventListener('click', () => playTrack('next'));
    }

    function buildPlaylist(data) {
      playlistElement.innerHTML = '';
      
      Object.entries(data).forEach(([genre, genreTracks]) => {
        if (!genreTracks.length) return;
        
        const details = document.createElement('details');
        const summary = document.createElement('summary');
        const tracksList = document.createElement('ul');
        
        details.className = 'genre-section';
        summary.textContent = genre;
        tracksList.className = 'track-list';
        
        genreTracks.forEach(track => {
          if (!track?.id || !track?.title) return;
          
          const li = document.createElement('li');
          li.textContent = track.title;
          li.className = 'track';
          li.dataset.id = track.id;
          li.dataset.genre = genre;
          li.addEventListener('click', () => playTrack('id', track.id));
          
          tracksList.appendChild(li);
        });
        
        details.appendChild(summary);
        details.appendChild(tracksList);
        playlistElement.appendChild(details);
      });
    }

    function playTrack(command, trackId = null) {
      if (!tracks.length) return;
      
      // Ensure MediaSession is initialized before playing
      if (!mediaSessionInitialized) {
        initializeMediaSession();
      }
      
      let newIndex = currentIndex;
      let addToHistory = true;
      
      // Determine which track to play based on command
      switch(command) {
        case 'id':
          // Find track by ID
          newIndex = tracks.findIndex(t => t.id === trackId);
          break;
          
        case 'next':
          // Navigate forward in history or play new track
          if (historyPosition < playHistory.length - 1) {
            historyPosition++;
            newIndex = playHistory[historyPosition];
            addToHistory = false;
          } else if (shuffleMode) {
            // Random track in shuffle mode
            newIndex = Math.floor(Math.random() * tracks.length);
            // Avoid playing the same track twice
            if (newIndex === currentIndex && tracks.length > 1) {
              newIndex = (newIndex + 1) % tracks.length;
            }
          } else {
            // Next track in sequence
            newIndex = (currentIndex + 1) % tracks.length;
          }
          break;
          
        case 'prev':
          // Navigate back in history or play previous track
          if (historyPosition > 0) {
            historyPosition--;
            newIndex = playHistory[historyPosition];
            addToHistory = false;
          } else {
            newIndex = (currentIndex - 1 + tracks.length) % tracks.length;
          }
          break;
      }
      
      if (newIndex === -1 || newIndex >= tracks.length) return;
      
      // Update history if needed
      if (addToHistory) {
        if (historyPosition < playHistory.length - 1) {
          playHistory = playHistory.slice(0, historyPosition + 1);
        }
        playHistory.push(newIndex);
        historyPosition = playHistory.length - 1;
      }
      
      // Update current track and play
      currentIndex = newIndex;
      const track = tracks[currentIndex];
      
      // Update UI
      document.querySelectorAll('.track.active').forEach(t => t.classList.remove('active'));
      const trackEl = document.querySelector(`.track[data-id="${track.id}"]`);
      if (trackEl) {
        trackEl.classList.add('active');
        const parentDetails = trackEl.closest('details');
        if (parentDetails) parentDetails.open = true;
      }
      
      nowPlayingElement.textContent = track.title;
      
      // Load and play audio
      const fileName = encodeURIComponent(track.title + '.mp3');
      const path = `/assets/static/music/${track.genre.toLowerCase()}/${fileName}`;
      
      audioElement.src = path;
      audioElement.load();
      
      // Update media session first
      updateMediaSession(track);
      
      // Then try to play
      audioElement.play().catch(error => {
        console.warn('Play prevented:', error);
        // Ensure MediaSession state reflects the actual state
        updateMediaSessionPlaybackState('paused');
        
        // For browsers requiring user interaction
        const userInteractionHandler = () => {
          audioElement.play()
            .then(() => {
              updateMediaSessionPlaybackState('playing');
            })
            .catch(e => {
              console.error('Play attempt failed after user interaction:', e);
              updateMediaSessionPlaybackState('paused');
            });
          document.removeEventListener('click', userInteractionHandler);
          document.removeEventListener('touchend', userInteractionHandler);
        };
        document.addEventListener('click', userInteractionHandler, { once: true });
        document.addEventListener('touchend', userInteractionHandler, { once: true });
      });
    }
    
    function updateMediaSession(track) {
      if (!ensureMediaSessionSupport()) return;
      
      try {
        if (!track || !track.title) {
          console.warn('MediaSession: Cannot update with invalid track data');
          return;
        }
        
        navigator.mediaSession.metadata = new MediaMetadata({
          title: track.title,
          artist: '',
          album: '',
          artwork: [
            { src: window.location.origin + '/assets/static/mw.jpeg', sizes: '512x512', type: 'image/jpeg' }
          ]
        });
        
        // Force sync of playback state when metadata changes
        updateMediaSessionPlaybackState(audioElement.paused ? 'paused' : 'playing');
      } catch (error) {
        console.warn('MediaSession metadata update error:', error);
        // Attempt recovery
        recoverMediaSessionState();
      }
    }
    
    // New function to ensure MediaSession support and initialization
    function ensureMediaSessionSupport() {
      if (!('mediaSession' in navigator) || !('MediaMetadata' in window)) {
        console.info('MediaSession API not supported in this browser');
        return false;
      }
      
      if (!mediaSessionInitialized) {
        initializeMediaSession();
      }
      
      return true;
    }
    
    // Renamed from setupMediaSession to be more explicit
    function initializeMediaSession() {
      if (!('mediaSession' in navigator) || !('MediaMetadata' in window)) {
        console.info('MediaSession API not supported in this browser');
        return;
      }
      
      try {
        // Initial empty metadata
        navigator.mediaSession.metadata = new MediaMetadata({
          title: '',
          artist: '',
          album: '',
          artwork: [
            { src: window.location.origin + '/assets/static/mw.jpeg', sizes: '512x512', type: 'image/jpeg' }
          ]
        });
        
        // Initial setup of action handlers
        setupMediaSessionActions();
        
        // Mark as initialized
        mediaSessionInitialized = true;
        
        // Set up periodic state sync (every 30 seconds)
        setInterval(syncMediaSessionState, 30000);
        
        console.info('MediaSession successfully initialized');
      } catch (error) {
        console.warn('MediaSession initialization error:', error);
        mediaSessionInitialized = false;
      }
    }
    
    function setupMediaSessionActions() {
      if (!('mediaSession' in navigator)) return;
      
      // Define all possible media actions
      try {
        navigator.mediaSession.setActionHandler('play', () => {
          audioElement.play().catch(e => console.warn('MediaSession: Play action failed:', e));
        });
        
        navigator.mediaSession.setActionHandler('pause', () => {
          audioElement.pause();
        });
        
        navigator.mediaSession.setActionHandler('previoustrack', () => {
          playTrack('prev');
        });
        
        navigator.mediaSession.setActionHandler('nexttrack', () => {
          playTrack('next');
        });
        
        // Optional: add support for seeking
        if ('seekbackward' in navigator.mediaSession) {
          navigator.mediaSession.setActionHandler('seekbackward', (details) => {
            const skipTime = details.seekOffset || 10;
            audioElement.currentTime = Math.max(audioElement.currentTime - skipTime, 0);
          });
        }
        
        if ('seekforward' in navigator.mediaSession) {
          navigator.mediaSession.setActionHandler('seekforward', (details) => {
            const skipTime = details.seekOffset || 10;
            audioElement.currentTime = Math.min(
              audioElement.currentTime + skipTime, 
              audioElement.duration || Infinity
            );
          });
        }
      } catch (error) {
        console.warn('MediaSession: Failed to set action handlers:', error);
      }
    }
    
    function updateMediaSessionPlaybackState(state) {
      if (!ensureMediaSessionSupport()) return;

      // Validate state value
      if (state !== 'playing' && state !== 'paused' && state !== 'none') {
        console.warn('MediaSession: Invalid playback state:', state);
        state = audioElement.paused ? 'paused' : 'playing';
      }

      try {
        navigator.mediaSession.playbackState = state;
        
        // Always update position state when playback state changes
        if (state === 'playing' || state === 'paused') {
          updateMediaSessionPositionState();
        }
      } catch (error) {
        console.warn('MediaSession: Error updating playback state:', error);
        // No need to retry here as this would create an infinite loop
      }
    }

    // New function to synchronize MediaSession state
    function syncMediaSessionState() {
      if (!mediaSessionInitialized || !ensureMediaSessionSupport()) {
        // Try to reinitialize if needed
        initializeMediaSession();
        return;
      }
      
      try {
        // Force sync with current audio state
        if (currentIndex >= 0 && currentIndex < tracks.length) {
          updateMediaSession(tracks[currentIndex]);
        }
        
        updateMediaSessionPlaybackState(audioElement.paused ? 'paused' : 'playing');
        
        if (!audioElement.paused && audioElement.duration) {
          updateMediaSessionPositionState();
        }
      } catch (error) {
        console.warn('MediaSession sync error:', error);
        // Try to recover
        recoverMediaSessionState();
      }
    }
    
    // New function to recover MediaSession state after errors
    function recoverMediaSessionState() {
      try {
        // Reinitialize MediaSession if something went wrong
        mediaSessionInitialized = false;
        initializeMediaSession();
        
        // If a track is loaded, update metadata
        if (currentIndex >= 0 && currentIndex < tracks.length) {
          updateMediaSession(tracks[currentIndex]);
        }
        
        // Update playback state
        updateMediaSessionPlaybackState(audioElement.paused ? 'paused' : 'playing');
      } catch (error) {
        console.error('Failed to recover MediaSession state:', error);
      }
    }

    // New function to specifically update position state
    function updateMediaSessionPositionState() {
      if (!('mediaSession' in navigator) || typeof navigator.mediaSession.setPositionState !== 'function') return;
      if (!audioElement || !audioElement.duration || !isFinite(audioElement.duration)) return; // Avoid issues with NaN or Infinity

      try {
        const position = audioElement.currentTime || 0;
        const duration = audioElement.duration || 0;
        const playbackRate = audioElement.playbackRate || 1;
        
        // Only update if we have valid values
        if (isFinite(position) && isFinite(duration) && isFinite(playbackRate) && duration > 0) {
          navigator.mediaSession.setPositionState({
            duration: duration,
            playbackRate: playbackRate,
            position: position
          });
        }
      } catch (error) {
        console.warn('MediaSession: Error updating position state:', error);
      }
    }

    // Refined timeupdate listener for MediaSession position state
    audioElement.addEventListener('timeupdate', () => {
      if (!('mediaSession' in navigator) || audioElement.paused) return;

      const currentSecond = Math.floor(audioElement.currentTime);
      // Update position state if the current second is a multiple of 5,
      // and we haven't updated for this specific second yet.
      // Also update when the distance from the last update exceeds 5 seconds
      if ((currentSecond % 5 === 0 && currentSecond !== lastUpdatedSecondForPosition) || 
          (Math.abs(currentSecond - lastUpdatedSecondForPosition) > 5)) {
        updateMediaSessionPositionState(); // Directly update position
        lastUpdatedSecondForPosition = currentSecond;
      }
    });

    // Update MediaSession on duration change
    audioElement.addEventListener('durationchange', () => {
      // When duration changes (e.g., new track loaded), update position state
      if (!audioElement.paused) {
        updateMediaSessionPositionState();
      }
    });

    // Update MediaSession when metadata is loaded
    audioElement.addEventListener('loadedmetadata', () => {
      // When metadata (including duration) is loaded, update position state
      // This is important for the initial load of a track
      // updateMediaSessionPositionState(); // Handled by updateMediaSessionPlaybackState
      // Also ensure playback state is correct if it was supposed to be playing
      // if (!audioElement.paused) {
      //  updateMediaSessionPlaybackState('playing');
      // }
      updateMediaSessionPlaybackState(audioElement.paused ? 'paused' : 'playing');
    });

    // Update MediaSession after seeking
    audioElement.addEventListener('seeked', () => {
      // After a seek operation, update the position state immediately
      if ('mediaSession' in navigator) {
        // Force immediate position update
        lastUpdatedSecondForPosition = -1; // Reset to force an update
        updateMediaSessionPositionState();
        // Also ensure playback state reflects current status
        updateMediaSessionPlaybackState(audioElement.paused ? 'paused' : 'playing');
      }
    });

    // Update MediaSession on playback rate change
    audioElement.addEventListener('ratechange', () => {
      if (!audioElement.paused) {
        updateMediaSessionPositionState(); // Update position state on rate change
      }
    });

    // Handle state sync for MediaSession on errors and track loads
    audioElement.addEventListener('error', (e) => {
      console.error('Audio element error:', e.target.error);
      updateMediaSessionPlaybackState('paused');
    });

    // Ensure state is synchronized when audio is loaded
    audioElement.addEventListener('loadeddata', () => {
      updateMediaSessionPlaybackState(audioElement.paused ? 'paused' : 'playing');
    });

    // Ensure state is synchronized on network state changes
    audioElement.addEventListener('stalled', () => {
      updateMediaSessionPlaybackState(audioElement.paused ? 'paused' : 'playing');
    });
    
    audioElement.addEventListener('waiting', () => {
      // If waiting for data but still "playing", we should reflect this in MediaSession
      if (!audioElement.paused) {
        updateMediaSessionPlaybackState('playing');
      }
    });
  });
</script>

<style>
  .audio-player {
    position: sticky;
    top: 0;
    font-size: 0.9rem;
    display: flex;
    flex-direction: column;
    align-items: stretch;
    z-index: 10;
  }

  #audio-player {
    width: 100%;
  }

  #now-playing {
    font-family: "Atkinson Hyperlegible Mono", "Inconsolata", monospace;
    padding-top: 0.5rem;
    padding-bottom: 0.5rem;
    margin-left: 1rem;
    background-color: #1b1c1d;
  }

  .player-controls {
    display: flex;
    justify-content: right;
  }

  .player-controls button {
    background-color: #1b1c1d;
    font-family: "Atkinson Hyperlegible Mono", "Inconsolata", monospace;
    cursor: pointer;
    border: none;
    font-size: 0.9rem;
  }

  #shuffle-button.active {
    color: #FF530D;
  }

  .track {
    cursor: pointer;
  }

  .track:hover {
    text-decoration: underline;
  }

  .track.active {
    color: #FF530D;
  }

  .track-list {
    margin-bottom: 1rem;
  }
</style>