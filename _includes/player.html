<!-- Simple Audio Player -->
<div class="audio-player">
  <div id="now-playing"></div>
  <audio id="audio-player" controls></audio>
  <div class="player-controls">
    <button id="prev-button" class="button">⏮</button>
    <button id="shuffle-button" class="button">shuffle</button>
    <button id="next-button" class="button">⏭</button>
  </div>
</div>

<div id="playlist"></div>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const audioElement = document.getElementById('audio-player');
    const nowPlayingElement = document.getElementById('now-playing');
    const playlistElement = document.getElementById('playlist');
    const shuffleBtn = document.getElementById('shuffle-button');
    const prevBtn = document.getElementById('prev-button');
    const nextBtn = document.getElementById('next-button');

    let tracks = [];
    let tracksById = {};
    let currentIndex = -1;
    let shuffleMode = false;
    let playHistory = [];
    let historyIndex = -1;
    let trackElements = [];
    let isIOS = false;
    init();

    async function init() {
      try {
        // Detect iOS for special handling
        isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        
        const data = await fetch('/assets/data/tracks.json').then(r => r.json());
        processData(data);
        setupUI(data);
        setupEvents();
      } catch (error) {
        console.error('Player error:', error);
        playlistElement.innerHTML = '<p>Failed to load music.</p>';
      }
    }

    function processData(data) {
      tracks = [];
      tracksById = {};

      Object.entries(data).forEach(([genre, genreTracks]) => {
        genreTracks.forEach(track => {
          if (!track || !track.id || !track.title) return;

          const trackWithGenre = { genre, id: track.id, title: track.title };
          tracks.push(trackWithGenre);
          tracksById[track.id] = trackWithGenre;
        });
      });
    }

    function setupUI(data) {
      playlistElement.innerHTML = '';
      trackElements = [];

      Object.entries(data).forEach(([genre, genreTracks]) => {
        const details = document.createElement('details');
        details.className = 'genre-section';
        details.open = false;

        const summary = document.createElement('summary');
        summary.textContent = genre;
        details.appendChild(summary);

        const tracksList = document.createElement('ul');
        tracksList.className = 'track-list';

        genreTracks.forEach(track => {
          if (!track || !track.id || !track.title) return;

          const li = document.createElement('li');
          li.textContent = track.title;
          li.className = 'track';
          li.dataset.id = track.id;
          li.dataset.genre = genre;

          const handleTrackClick = () => playById(track.id);
          li.addEventListener('click', handleTrackClick);

          // Store reference to element and handler for cleanup
          trackElements.push({
            element: li,
            handler: handleTrackClick,
            id: track.id
          });

          tracksList.appendChild(li);
        });

        details.appendChild(tracksList);
        playlistElement.appendChild(details);
      });
    }

    function setupEvents() {
      // Audio event listeners
      const updateSession = () => {
        if (currentIndex >= 0 && tracks[currentIndex]) {
          updateMediaSession(tracks[currentIndex].title);
        }
      };

      audioElement.addEventListener('ended', () => playNext());
      audioElement.addEventListener('error', (e) => {
        console.warn('Audio error:', e);
        playNext();
      });
      audioElement.addEventListener('pause', updateSession);
      audioElement.addEventListener('play', updateSession);
      
      // Only update position state if the browser supports it and not on iOS
      if ('mediaSession' in navigator && 'setPositionState' in navigator.mediaSession && !isIOS) {
        audioElement.addEventListener('loadedmetadata', updatePositionState);
        audioElement.addEventListener('timeupdate', updatePositionState);
      }

      // Add specific event for iOS to handle interruptions
      if (isIOS) {
        document.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'visible' && !audioElement.paused) {
            // iOS sometimes stops media when app goes to background
            // Try to resume playback when coming back
            audioElement.play().catch(e => console.warn('Resume after visibility change failed:', e));
          }
        });
      }

      // Button event listeners
      shuffleBtn.addEventListener('click', toggleShuffle);
      prevBtn.addEventListener('click', playPrev);
      nextBtn.addEventListener('click', playNext);
    }

    function playById(id) {
      const index = tracks.findIndex(t => t.id === id);
      if (index !== -1) {
        // When directly selecting a track, clear future history
        if (historyIndex < playHistory.length - 1) {
          playHistory = playHistory.slice(0, historyIndex + 1);
        }

        updateHistoryAndPlay(index);
      }
    }

    function updateTrackUI(track) {
      // Update active track in UI
      document.querySelectorAll('.track.active').forEach(t => t.classList.remove('active'));
      const trackEl = document.querySelector(`.track[data-id="${track.id}"]`);
      if (trackEl) {
        trackEl.classList.add('active');
        const parentDetails = trackEl.closest('details');
        if (parentDetails) parentDetails.open = true;
      }

      nowPlayingElement.textContent = track.title;
    }

    function loadTrack() {
      const track = tracks[currentIndex];
      if (!track) return;

      updateTrackUI(track);

      // Load and play the track
      const fileName = encodeURIComponent(track.title + '.mp3');
      const path = `/assets/static/music/${track.genre.toLowerCase()}/${fileName}`;

      // Stop any current playback first to avoid iOS issues
      audioElement.pause();
      
      // Set src and load the audio
      audioElement.src = path;
      
      // Special handling for iOS
      if (isIOS) {
        // iOS often needs a user interaction to play
        // We'll set everything up but may not auto-play
        audioElement.load();
        audioElement.play().catch(error => {
          console.warn('iOS autoplay failed, waiting for user interaction:', error);
        });
        updateMediaSession(track.title);
      } else {
        // Normal flow for other browsers
        audioElement.load();
        audioElement.play()
          .then(() => {
            updateMediaSession(track.title);
          })
          .catch(error => {
            console.error('Error playing track:', error);
            setTimeout(playNext, 300);
          });
      }
    }

    function updateHistoryAndPlay(index) {
      currentIndex = index;
      playHistory.push(index);
      historyIndex = playHistory.length - 1;
      loadTrack();
    }

    function playNext() {
      if (!tracks.length) return;

      // Check if we're already navigating through history
      if (historyIndex < playHistory.length - 1) {
        // Move forward in history
        historyIndex++;
        currentIndex = playHistory[historyIndex];
        loadTrack();
        return;
      }

      // Otherwise play the next track normally
      let nextIndex;
      if (shuffleMode) {
        // Random track in shuffle mode
        nextIndex = Math.floor(Math.random() * tracks.length);
        // Avoid playing the same track twice
        if (nextIndex === currentIndex && tracks.length > 1) {
          nextIndex = (nextIndex + 1) % tracks.length;
        }
      } else {
        // Next track in sequence
        nextIndex = (currentIndex + 1) % tracks.length;
      }

      updateHistoryAndPlay(nextIndex);
    }

    function playPrev() {
      if (!tracks.length) return;

      // If we have history and not at the beginning
      if (historyIndex > 0) {
        historyIndex--;
        currentIndex = playHistory[historyIndex];
        loadTrack();
        return;
      }

      // If at the start of history or no history, use the default behavior
      const prevIndex = (currentIndex - 1 + tracks.length) % tracks.length;

      updateHistoryAndPlay(prevIndex);
    }

    function toggleShuffle() {
      shuffleMode = !shuffleMode;
      shuffleBtn.classList.toggle('active', shuffleMode);
      shuffleBtn.setAttribute('aria-pressed', shuffleMode);

      // Auto-start playback if paused and shuffle enabled
      if (shuffleMode && audioElement.paused && tracks.length > 0) {
        playNext();
      }
    }


    function updateMediaSession(trackTitle) {
      if (!('mediaSession' in navigator)) return;

      try {
        const artworkPath = window.location.origin + '/assets/static/mw.jpeg';
        navigator.mediaSession.metadata = new MediaMetadata({
          title: trackTitle,
          artwork: [
            { src: artworkPath, sizes: '512x512', type: 'image/jpeg' }
          ]
        });

        // Use simpler handlers for iOS compatibility
        const actionHandlers = [
          ['play', () => audioElement.play().catch(e => console.warn('Play failed:', e))],
          ['pause', () => audioElement.pause()],
          ['previoustrack', playPrev],
          ['nexttrack', playNext]
        ];

        // Only add seekto if not on iOS, as it can be problematic
        if (!isIOS) {
          actionHandlers.push(['seekto', details => {
            try {
              audioElement.currentTime = details.seekTime;
            } catch (e) {
              console.warn('Error during seek:', e);
            }
          }]);
        }

        // Register each handler with proper feature detection
        actionHandlers.forEach(([action, handler]) => {
          try {
            navigator.mediaSession.setActionHandler(action, handler);
          } catch (e) {
            console.warn(`MediaSession: ${action} is not supported`, e);
          }
        });

        // Only update position state if supported and not on iOS
        if ('setPositionState' in navigator.mediaSession && !isIOS) {
          updatePositionState();
        }
      } catch (e) {
        console.warn('Error setting up media session:', e);
      }
    }

    function updatePositionState() {
      if (!('mediaSession' in navigator) || 
          !('setPositionState' in navigator.mediaSession) || 
          audioElement.readyState === 0) return;

      try {
        const duration = audioElement.duration;
        const position = audioElement.currentTime;
        const playbackRate = audioElement.playbackRate;
        
        // Check for valid values - iOS sometimes returns NaN
        if (!isNaN(duration) && !isNaN(position) && !isNaN(playbackRate) && duration > 0) {
          navigator.mediaSession.setPositionState({
            duration: duration,
            playbackRate: playbackRate,
            position: position
          });
        }
      } catch (e) {
        console.warn('Error updating position state:', e);
      }
    }

  });
</script>

<style>
  .audio-player {
    position: sticky;
    top: 0;
    font-size: 0.9rem;
    display: flex;
    flex-direction: column;
    align-items: stretch;
    z-index: 10;
  }

  #audio-player {
    width: 100%;
  }

  #now-playing {
    font-family: "Atkinson Hyperlegible Mono", "Inconsolata", monospace;
    padding-top: 0.5rem;
    padding-bottom: 0.5rem;
    margin-left: 1rem;
    background-color: #1b1c1d;
  }

  .player-controls {
    display: flex;
    justify-content: right;
  }

  .player-controls button {
    background-color: #1b1c1d;
    font-family: "Atkinson Hyperlegible Mono", "Inconsolata", monospace;
    cursor: pointer;
    border: none;
    font-size: 0.9rem;
  }

  #shuffle-button.active {
    color: #FF530D;
  }

  .track {
    cursor: pointer;
  }

  .track:hover {
    text-decoration: underline;
  }

  .track.active {
    color: #FF530D;
  }

  .track-list {
    margin-bottom: 1rem;
  }
</style>