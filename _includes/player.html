<!-- Simple Audio Player -->
<div class="audio-player">
  <div id="now-playing"></div>
  <audio id="audio-player" controls></audio>
  <div class="player-controls">
    <button id="prev-button" class="button">⏮</button>
    <button id="shuffle-button" class="button">shuffle</button>
    <button id="next-button" class="button">⏭</button>
  </div>
</div>

<div id="playlist"></div>

<div id="queue"></div>


<script>
document.addEventListener('DOMContentLoaded', () => {
  const player = {
    // DOM Elements
    audio: document.getElementById('audio-player'),
    nowPlaying: document.getElementById('now-playing'),
    playlist: document.getElementById('playlist'),
    shuffleBtn: document.getElementById('shuffle-button'),
    prevBtn: document.getElementById('prev-button'),
    nextBtn: document.getElementById('next-button'),
    
    // State
    tracks: [],
    tracksById: {},
    currentIndex: -1,
    shuffleMode: false,
    playHistory: [],     // Array to store play history
    historyIndex: -1,    // Current position in history
    
    async init() {
      try {
        const data = await fetch('/assets/data/tracks.json').then(r => r.json());
        this.processData(data);
        this.setupUI(data);
        this.setupEvents();
      } catch (error) {
        console.error('Player error:', error);
        this.playlist.innerHTML = '<p>Failed to load music.</p>';
      }
    },
    
    processData(data) {
      this.tracks = [];
      this.tracksById = {};
      
      Object.entries(data).forEach(([genre, tracks]) => {
        tracks.forEach(track => {
          if (!track || !track.id || !track.title) return;
          
          const trackWithGenre = { genre, id: track.id, title: track.title };
          this.tracks.push(trackWithGenre);
          this.tracksById[track.id] = trackWithGenre;
        });
      });
    },
    
    setupUI(data) {
      this.playlist.innerHTML = '';
      this.trackElements = [];
      
      Object.entries(data).forEach(([genre, tracks], index) => {
        const details = document.createElement('details');
        details.className = 'genre-section';
        details.open = false;
        
        const summary = document.createElement('summary');
        summary.textContent = genre;
        details.appendChild(summary);
        
        const tracksList = document.createElement('ul');
        tracksList.className = 'track-list';
        
        tracks.forEach(track => {
          if (!track || !track.id || !track.title) return;
          
          const li = document.createElement('li');
          li.textContent = track.title;
          li.className = 'track';
          li.dataset.id = track.id;
          li.dataset.genre = genre;
          
          const handleTrackClick = () => this.playById(track.id);
          li.addEventListener('click', handleTrackClick);
          
          // Store reference to element and handler for cleanup
          this.trackElements.push({ 
            element: li, 
            handler: handleTrackClick,
            id: track.id
          });
          
          tracksList.appendChild(li);
        });
        
        details.appendChild(tracksList);
        this.playlist.appendChild(details);
      });
    },
    
    setupEvents() {
      // Player events
      this.handleTrackEnd = () => this.playNext();
      this.handleError = () => {
        this.nowPlaying.textContent = 'Error playing track';
        setTimeout(() => this.playNext(), 500);
      };
      this.handleShuffleClick = () => this.toggleShuffle();
      this.handlePrevClick = () => this.playPrev();
      this.handleNextClick = () => this.playNext();
      
      this.handlePause = () => {
        this.updatePositionState();
      };
      this.handleTimeUpdate = () => {
        // Update position state periodically (throttled to reduce overhead)
        if (this.lastPositionUpdate && Date.now() - this.lastPositionUpdate < 3000) return;
        this.lastPositionUpdate = Date.now();
        this.updatePositionState();
      };
      this.handleDurationChange = () => {
        this.updatePositionState();
      };
      
      // Define audio event mappings
      this.audioEvents = {
        'ended': this.handleTrackEnd,
        'error': this.handleError,
        'pause': this.handlePause,
        'timeupdate': this.handleTimeUpdate,
        'durationchange': this.handleDurationChange
      };
      
      // Button event mappings
      this.buttonEvents = [
        { element: this.shuffleBtn, event: 'click', handler: this.handleShuffleClick },
        { element: this.prevBtn, event: 'click', handler: this.handlePrevClick },
        { element: this.nextBtn, event: 'click', handler: this.handleNextClick }
      ];
      
      // Add all audio events
      Object.entries(this.audioEvents).forEach(([event, handler]) => {
        this.audio.addEventListener(event, handler);
      });
      
      // Add all button events
      this.buttonEvents.forEach(({ element, event, handler }) => {
        element.addEventListener(event, handler);
      });
    },
    
    playById(id) {
      const index = this.tracks.findIndex(t => t.id === id);
      if (index !== -1) {
        this.currentIndex = index;
        
        // When directly selecting a track, clear future history
        if (this.historyIndex < this.playHistory.length - 1) {
          this.playHistory = this.playHistory.slice(0, this.historyIndex + 1);
        }
        
        // Add to history and update index
        this.playHistory.push(index);
        this.historyIndex = this.playHistory.length - 1;
        
        this.loadTrack();
      }
    },
    
    loadTrack() {
      const track = this.tracks[this.currentIndex];
      if (!track) return;
      
      // Update active track in UI
      document.querySelectorAll('.track.active').forEach(t => t.classList.remove('active'));
      const trackEl = document.querySelector(`.track[data-id="${track.id}"]`);
      if (trackEl) {
        trackEl.classList.add('active');
        const parentDetails = trackEl.closest('details');
        if (parentDetails) parentDetails.open = true;
      }
      
      // Load and play the track
      const fileName = encodeURIComponent(track.title + '.mp3');
      const path = `/assets/static/music/${track.genre.toLowerCase()}/${fileName}`;
      
      this.nowPlaying.textContent = track.title;
      this.audio.src = path;    

      this.audio.play()
      .then(() => {
        this.updateMediaSession(track.title);
      })
      .catch(error => {
        console.error('Play error:', error);
        this.nowPlaying.textContent = `Error: ${track.title}`;
        setTimeout(() => this.playNext(), 2000);
      });
    },
    
    updateMediaSession(trackTitle) {
      if (!('mediaSession' in navigator)) return;
      
      const artworkPath = window.location.origin + '/assets/static/mw.jpeg'
      
      navigator.mediaSession.metadata = new MediaMetadata({
        title: trackTitle,
        artwork: [
          { src: artworkPath, sizes: '512x512', type: 'image/jpeg' }
        ] 
      });
      
      // Set up media session actions
      navigator.mediaSession.setActionHandler('previoustrack', () => this.playPrev());
      navigator.mediaSession.setActionHandler('nexttrack', () => this.playNext());
      navigator.mediaSession.setActionHandler('play', () => this.audio.play());
      navigator.mediaSession.setActionHandler('pause', () => this.audio.pause());
      
      // Add seek handler for compatible browsers
      navigator.mediaSession.setActionHandler('seekto', (details) => {
        if (details.fastSeek && 'fastSeek' in this.audio) {
          this.audio.fastSeek(details.seekTime);
          return;
        }
        this.audio.currentTime = details.seekTime;
      });
      
      this.updatePositionState();
    },

    // Update position state for lock screen
    updatePositionState() {
      if (!('mediaSession' in navigator) || !('setPositionState' in navigator.mediaSession)) return;
      
      if (isNaN(this.audio.duration)) return;
      
      navigator.mediaSession.setPositionState({
        duration: this.audio.duration || 0,
        playbackRate: this.audio.playbackRate || 1,
        position: this.audio.currentTime || 0
      });
    },
    
    playNext() {
      if (!this.tracks.length) return;
      
      // Check if we're already navigating through history
      if (this.historyIndex < this.playHistory.length - 1) {
        // Move forward in history
        this.historyIndex++;
        this.currentIndex = this.playHistory[this.historyIndex];
        this.loadTrack();
        return;
      }
      
      // Otherwise play the next track normally
      let nextIndex;
      if (this.shuffleMode) {
        // Random track in shuffle mode
        nextIndex = Math.floor(Math.random() * this.tracks.length);
        // Avoid playing the same track twice
        if (nextIndex === this.currentIndex && this.tracks.length > 1) {
          nextIndex = (nextIndex + 1) % this.tracks.length;
        }
      } else {
        // Next track in sequence
        nextIndex = (this.currentIndex + 1) % this.tracks.length;
      }
      
      // Update current index and add to history
      this.currentIndex = nextIndex;
      this.playHistory.push(nextIndex);
      this.historyIndex = this.playHistory.length - 1;
      
      this.loadTrack();
    },
    
    playPrev() {
      if (!this.tracks.length) return;
      
      // If we have history and not at the beginning
      if (this.historyIndex > 0) {
        this.historyIndex--;
        this.currentIndex = this.playHistory[this.historyIndex];
        this.loadTrack();
        return;
      }
      
      // If at the start of history or no history, use the default behavior
      this.currentIndex = (this.currentIndex - 1 + this.tracks.length) % this.tracks.length;
      
      // Add to history since we're going to a new track not in history
      this.playHistory.push(this.currentIndex);
      this.historyIndex = this.playHistory.length - 1;
      
      this.loadTrack();
    },
    
    toggleShuffle() {
      this.shuffleMode = !this.shuffleMode;
      this.shuffleBtn.classList.toggle('active', this.shuffleMode);
      this.shuffleBtn.setAttribute('aria-pressed', this.shuffleMode);
      
      // Auto-start playback if paused and shuffle enabled
      if (this.shuffleMode && this.audio.paused && this.tracks.length > 0) {
        this.playNext();
      }
    },
    
    cleanup() {
      // Clean up media session handlers
      if ('mediaSession' in navigator) {
        navigator.mediaSession.setActionHandler('previoustrack', null);
        navigator.mediaSession.setActionHandler('nexttrack', null);
        navigator.mediaSession.setActionHandler('play', null);
        navigator.mediaSession.setActionHandler('pause', null);
        navigator.mediaSession.setActionHandler('seekto', null);
      }
      
      // Remove all audio event listeners
      Object.entries(this.audioEvents).forEach(([event, handler]) => {
        this.audio.removeEventListener(event, handler);
      });
      
      // Remove all button event listeners
      this.buttonEvents.forEach(({ element, event, handler }) => {
        element.removeEventListener(event, handler);
      });
      
      // Remove event listeners from track elements
      if (this.trackElements) {
        this.trackElements.forEach(item => {
          item.element.removeEventListener('click', item.handler);
        });
      }
      
      // Remove window event listener
      window.removeEventListener('beforeunload', this.handleUnload);
    }
  };
  
  // Initialize the player
  player.init();
  
  // Create a named handler for window unload event
  player.handleUnload = () => player.cleanup();
  
  // Cleanup when page is unloaded
  window.addEventListener('beforeunload', player.handleUnload);
});
</script>

<style>
  .audio-player {
    position: sticky;
    top: 0;
    font-size: 0.9rem;
    display: flex;
    flex-direction: column;
    align-items: stretch;
    z-index: 10;
  }

  #audio-player {
    width: 100%;
  }
  
  #now-playing {
    font-family: "Atkinson Hyperlegible Mono", "Inconsolata", monospace;
    padding-top: 0.5rem;
    padding-bottom: 0.5rem;
    margin-left: 1rem;
    background-color: #1b1c1d;
  }

  .player-controls {
    display: flex;
    justify-content: right;
  }
  
  .player-controls button {
    background-color: #1b1c1d;
    font-family: "Atkinson Hyperlegible Mono", "Inconsolata", monospace;  
    cursor: pointer;
    border: none;
    font-size: 0.9rem;
  }
  
  #shuffle-button.active {
    color: #FF530D;
  }

  .track {
    cursor: pointer;
  }
  
  .track:hover {
    text-decoration: underline;
  }
  
  .track.active {
    color: #FF530D;
  }
  
  .track-list {
    margin-bottom: 1rem;
  }
</style>