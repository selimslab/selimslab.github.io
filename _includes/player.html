<!-- Simple Audio Player -->
<div class="audio-player">
  <div id="now-playing"></div>
  <audio id="audio-player" controls></audio>
  <div class="player-controls">
    <button id="prev-button" class="button">⏮</button>
    <button id="shuffle-button" class="button">shuffle</button>
    <button id="next-button" class="button">⏭</button>
  </div>
</div>

<div id="playlist"></div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const audioElement = document.getElementById('audio-player');
  const nowPlayingElement = document.getElementById('now-playing');
  const playlistElement = document.getElementById('playlist');
  const shuffleBtn = document.getElementById('shuffle-button');
  const prevBtn = document.getElementById('prev-button');
  const nextBtn = document.getElementById('next-button');
  
  let tracks = [];
  let tracksById = {};
  let currentIndex = -1;
  let shuffleMode = false;
  let playHistory = [];     
  let historyIndex = -1;    
  let trackElements = [];  
  init();
  
  async function init() {
    try {
      const data = await fetch('/assets/data/tracks.json').then(r => r.json());
      processData(data);
      setupUI(data);
      setupEvents();
    } catch (error) {
      console.error('Player error:', error);
      playlistElement.innerHTML = '<p>Failed to load music.</p>';
    }
  }
  
  function processData(data) {
    tracks = [];
    tracksById = {};
    
    Object.entries(data).forEach(([genre, genreTracks]) => {
      genreTracks.forEach(track => {
        if (!track || !track.id || !track.title) return;
        
        const trackWithGenre = { genre, id: track.id, title: track.title };
        tracks.push(trackWithGenre);
        tracksById[track.id] = trackWithGenre;
      });
    });
  }
  
  function setupUI(data) {
    playlistElement.innerHTML = '';
    trackElements = [];
    
    Object.entries(data).forEach(([genre, genreTracks]) => {
      const details = document.createElement('details');
      details.className = 'genre-section';
      details.open = false;
      
      const summary = document.createElement('summary');
      summary.textContent = genre;
      details.appendChild(summary);
      
      const tracksList = document.createElement('ul');
      tracksList.className = 'track-list';
      
      genreTracks.forEach(track => {
        if (!track || !track.id || !track.title) return;
        
        const li = document.createElement('li');
        li.textContent = track.title;
        li.className = 'track';
        li.dataset.id = track.id;
        li.dataset.genre = genre;
        
        const handleTrackClick = () => playById(track.id);
        li.addEventListener('click', handleTrackClick);
        
        // Store reference to element and handler for cleanup
        trackElements.push({ 
          element: li, 
          handler: handleTrackClick,
          id: track.id
        });
        
        tracksList.appendChild(li);
      });
      
      details.appendChild(tracksList);
      playlistElement.appendChild(details);
    });
  }
  
  function setupEvents() {
    // Audio event listeners
    const updateSession = () => updateMediaSession(tracks[currentIndex]?.title)

    audioElement.addEventListener('ended', () => playNext());
    audioElement.addEventListener('error', () => playNext());
    audioElement.addEventListener('pause', () => updateSession());
    audioElement.addEventListener('play', () => updateSession());
    audioElement.addEventListener('timeupdate', () => updateSession());
    audioElement.addEventListener('durationchange', () => updateSession());
    
    // Button event listeners
    shuffleBtn.addEventListener('click', toggleShuffle);
    prevBtn.addEventListener('click', playPrev);
    nextBtn.addEventListener('click', playNext);
    
  }
  


  function playById(id) {
    const index = tracks.findIndex(t => t.id === id);
    if (index !== -1) {
      // When directly selecting a track, clear future history
      if (historyIndex < playHistory.length - 1) {
        playHistory = playHistory.slice(0, historyIndex + 1);
      }
      
      updateHistoryAndPlay(index);
    }
  }
  
  function updateTrackUI(track) {
    // Update active track in UI
    document.querySelectorAll('.track.active').forEach(t => t.classList.remove('active'));
    const trackEl = document.querySelector(`.track[data-id="${track.id}"]`);
    if (trackEl) {
      trackEl.classList.add('active');
      const parentDetails = trackEl.closest('details');
      if (parentDetails) parentDetails.open = true;
    }
    
    nowPlayingElement.textContent = track.title;
  }

  function loadTrack() {
    const track = tracks[currentIndex];
    if (!track) return;
    
    updateTrackUI(track);
    
    // Load and play the track
    const fileName = encodeURIComponent(track.title + '.mp3');
    const path = `/assets/static/music/${track.genre.toLowerCase()}/${fileName}`;
    
    // Update media session metadata before setting audio source
    updateMediaSession(track.title);
    
    audioElement.src = path;    
    audioElement.load(); // Explicitly load before playing
    audioElement.play().then(() => {
      // Ensure metadata is updated after successful play
      updateMediaSession(track.title);
    }).catch(error => {
      console.error('Error playing track:', error);
      playNext();
    });
  }
  
  function updateMediaSession(trackTitle) {
    if (!('mediaSession' in navigator)) return;
    
    try {

      const artworkPath = window.location.origin + '/assets/static/mw.jpeg';
      
      navigator.mediaSession.metadata = new MediaMetadata({
        title: trackTitle,
        artist: '', 
        album: '', 
        artwork: [
          { src: artworkPath, sizes: '512x512', type: 'image/jpeg' },
          { src: artworkPath, sizes: '96x96', type: 'image/jpeg' }
        ] 
      });
            
      setMediaSessionActionHandlers();

      updatePositionState();
    } catch (e) {
      console.warn('Error setting up media session:', e);
    }
  }

  const play = () => audioElement.play();
  const pause = () => audioElement.pause();

  function setMediaSessionActionHandlers() {
    if (!('mediaSession' in navigator)) return;

    const mediaActionHandlers = [
      { action: 'previoustrack', handler: playPrev },
      { action: 'nexttrack', handler: playNext },
      { action: 'play', handler: play },
      { action: 'pause', handler: pause }
    ];

    // Conditionally add seekto handler if setPositionState is supported
    if ('setPositionState' in navigator.mediaSession) {
      mediaActionHandlers.push({
        action: 'seekto',
        handler: (details) => {
          if (details.fastSeek && 'fastSeek' in audioElement) {
            audioElement.fastSeek(details.seekTime);
            return;
          }
          audioElement.currentTime = details.seekTime;
        }
      });
    }

    mediaActionHandlers.forEach(item => {
      try {
        navigator.mediaSession.setActionHandler(item.action, item.handler);
      } catch (e) {
        console.warn(`Error setting media session handler for ${item.action}:`, e);
      }
    });
  }
  
  function updatePositionState() {
    // Check if feature is supported before using
    if (!('mediaSession' in navigator) || !('setPositionState' in navigator.mediaSession)) {
      return;
    }
    
    // Only update if audio element has a valid duration
    if (!audioElement || !isFinite(audioElement.duration) || audioElement.duration <= 0) {
      return;
    }
    
    try {
      navigator.mediaSession.setPositionState({
        duration: audioElement.duration || 0,
        playbackRate: audioElement.playbackRate || 1,
        position: audioElement.currentTime || 0
      });
    } catch (e) {
      console.warn('Error updating position state:', e);
    }
  }
  
  function updateHistoryAndPlay(index) {
    currentIndex = index;
    playHistory.push(index);
    historyIndex = playHistory.length - 1;
    loadTrack();
  }
  
  function playNext() {
    if (!tracks.length) return;
    
    // Check if we're already navigating through history
    if (historyIndex < playHistory.length - 1) {
      // Move forward in history
      historyIndex++;
      currentIndex = playHistory[historyIndex];
      loadTrack();
      return;
    }
    
    // Otherwise play the next track normally
    let nextIndex;
    if (shuffleMode) {
      // Random track in shuffle mode
      nextIndex = Math.floor(Math.random() * tracks.length);
      // Avoid playing the same track twice
      if (nextIndex === currentIndex && tracks.length > 1) {
        nextIndex = (nextIndex + 1) % tracks.length;
      }
    } else {
      // Next track in sequence
      nextIndex = (currentIndex + 1) % tracks.length;
    }
    
    updateHistoryAndPlay(nextIndex);
  }
  
  function playPrev() {
    if (!tracks.length) return;
    
    // If we have history and not at the beginning
    if (historyIndex > 0) {
      historyIndex--;
      currentIndex = playHistory[historyIndex];
      loadTrack();
      return;
    }
    
    // If at the start of history or no history, use the default behavior
    const prevIndex = (currentIndex - 1 + tracks.length) % tracks.length;
    
    updateHistoryAndPlay(prevIndex);
  }
  
  function toggleShuffle() {
    shuffleMode = !shuffleMode;
    shuffleBtn.classList.toggle('active', shuffleMode);
    shuffleBtn.setAttribute('aria-pressed', shuffleMode);
    
    // Auto-start playback if paused and shuffle enabled
    if (shuffleMode && audioElement.paused && tracks.length > 0) {
      playNext();
    }
  }
  
});
</script>

<style>
  .audio-player {
    position: sticky;
    top: 0;
    font-size: 0.9rem;
    display: flex;
    flex-direction: column;
    align-items: stretch;
    z-index: 10;
  }

  #audio-player {
    width: 100%;
  }
  
  #now-playing {
    font-family: "Atkinson Hyperlegible Mono", "Inconsolata", monospace;
    padding-top: 0.5rem;
    padding-bottom: 0.5rem;
    margin-left: 1rem;
    background-color: #1b1c1d;
  }

  .player-controls {
    display: flex;
    justify-content: right;
  }
  
  .player-controls button {
    background-color: #1b1c1d;
    font-family: "Atkinson Hyperlegible Mono", "Inconsolata", monospace;  
    cursor: pointer;
    border: none;
    font-size: 0.9rem;
  }
  
  #shuffle-button.active {
    color: #FF530D;
  }

  .track {
    cursor: pointer;
  }
  
  .track:hover {
    text-decoration: underline;
  }
  
  .track.active {
    color: #FF530D;
  }
  
  .track-list {
    margin-bottom: 1rem;
  }
</style>