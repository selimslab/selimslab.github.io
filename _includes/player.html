<!-- Simple Audio Player -->
<div class="audio-player">
  <div id="now-playing"></div>
  <audio id="audio-player" controls></audio>
  <div class="player-controls">
    <button id="shuffle-button" class="button is-small">shuffle</button>
  </div>
</div>

<div id="playlist"></div>

<div id="queue"></div>


<script>
document.addEventListener('DOMContentLoaded', () => {
  const audioPlayer = {
    // DOM Elements
    elements: {
      player: document.getElementById('audio-player'),
      nowPlaying: document.getElementById('now-playing'),
      playlist: document.getElementById('playlist'),
      shuffleButton: document.getElementById('shuffle-button')
    },
    
    // State
    state: {
      currentIndex: -1,
      tracks: [],
      tracksById: {},
      shuffleMode: false,
      isInitialized: false
    },
    
    // Initialize the player
    async init() {
      if (this.state.isInitialized) return;
      
      try {
        await this.loadData();
        this.setupEventListeners();
        this.updateShuffleButton();
        this.state.isInitialized = true;
      } catch (error) {
        console.error('Player initialization error:', error);
        this.elements.playlist.innerHTML = '<p>Failed to load music.</p>';
      }
    },
    
    // Load all data needed for the player
    async loadData() {
      try {
        const tracksData = await this.fetchJSON('/assets/data/tracks.json');
        if (!tracksData || Object.keys(tracksData).length === 0) {
          throw new Error('No tracks data available');
        }
        this.processTrackData(tracksData);
        this.buildPlaylist(tracksData);
      } catch (error) {
        console.error('Error loading tracks data:', error);
        throw error;
      }
    },
    
    // Fetch and parse JSON data
    async fetchJSON(url) {
      try {
        const response = await fetch(url, { cache: 'no-store' });
        if (!response.ok) {
          throw new Error(`Failed to load ${url}: ${response.status}`);
        }
        return response.json();
      } catch (error) {
        console.error(`Error fetching ${url}:`, error);
        throw error;
      }
    },
    
    // Set up event handlers
    setupEventListeners() {
      const { player, shuffleButton } = this.elements;
      
      // Clean up any existing event listeners first
      this.removeEventListeners();
      
      // Main player controls
      this.eventHandlers = {
        ended: () => this.playTrack('next'),
        loadedmetadata: () => this.updatePositionState(),
        timeupdate: () => this.updatePositionState(),
        error: (e) => this.handlePlayerError(e),
        shuffleClick: () => this.toggleShuffle()
      };
      
      player.addEventListener('ended', this.eventHandlers.ended);
      player.addEventListener('loadedmetadata', this.eventHandlers.loadedmetadata);
      player.addEventListener('timeupdate', this.eventHandlers.timeupdate);
      player.addEventListener('error', this.eventHandlers.error);
      shuffleButton.addEventListener('click', this.eventHandlers.shuffleClick);
    },
    
    // Clean up event listeners to prevent memory leaks
    removeEventListeners() {
      if (!this.eventHandlers) return;
      
      const { player, shuffleButton } = this.elements;
      
      if (player) {
        player.removeEventListener('ended', this.eventHandlers.ended);
        player.removeEventListener('loadedmetadata', this.eventHandlers.loadedmetadata);
        player.removeEventListener('timeupdate', this.eventHandlers.timeupdate);
        player.removeEventListener('error', this.eventHandlers.error);
      }
      
      if (shuffleButton) {
        shuffleButton.removeEventListener('click', this.eventHandlers.shuffleClick);
      }
    },
    
    // Handle audio player errors
    handlePlayerError(error) {
      console.error('Audio player error:', error);
      const currentTrack = this.getCurrentTrack();
      this.elements.nowPlaying.textContent = currentTrack 
        ? `Error playing: ${currentTrack.title}` 
        : 'Error playing track';
        
      // Try to play next track after a short delay
      setTimeout(() => this.playTrack('next'), 2000);
    },
    
    // Process track data into flat array with genre info
    processTrackData(data) {
      this.state.tracks = [];
      this.state.tracksById = {};
      
      Object.entries(data).forEach(([genre, tracks]) => {
        if (!Array.isArray(tracks)) return;
        
        tracks.forEach(track => {
          if (!track || !track.id || !track.title) return;
          
          const trackWithGenre = { genre, id: track.id, title: track.title };
          this.state.tracks.push(trackWithGenre);
          this.state.tracksById[track.id] = trackWithGenre;
        });
      });
    },
    
    // Build the playlist UI
    buildPlaylist(data) {
      const playlist = this.elements.playlist;
      playlist.innerHTML = '';
      
      if (!data || Object.keys(data).length === 0) {
        playlist.innerHTML = '<p>No tracks available.</p>';
        return;
      }
      
      Object.entries(data).forEach(([genre, tracks]) => {
        if (!Array.isArray(tracks) || tracks.length === 0) return;
        
        const genreElement = this.createGenreSection(genre, tracks);
        playlist.appendChild(genreElement);
      });
    },
    
    // Create a collapsible genre section
    createGenreSection(genre, tracks) {
      const details = document.createElement('details');
      details.className = 'genre-section';
      
      // Open first genre by default
      if (this.elements.playlist.childElementCount === 0) {
        details.open = true;
      }
      
      const summary = document.createElement('summary');
      summary.textContent = genre;
      details.appendChild(summary);
      
      const tracksList = document.createElement('ul');
      tracksList.className = 'track-list';
      
      tracks.forEach(track => {
        if (!track || !track.id || !track.title) return;
        
        const trackItem = this.createTrackItem(genre, track);
        tracksList.appendChild(trackItem);
      });
      
      details.appendChild(tracksList);
      return details;
    },
    
    // Create a track list item
    createTrackItem(genre, track) {
      const trackItem = document.createElement('li');
      trackItem.textContent = track.title;
      trackItem.className = 'track';
      trackItem.dataset.genre = genre;
      trackItem.dataset.id = track.id;
      
      // Use a delegated event handler to save memory
      trackItem.addEventListener('click', () => this.handleTrackClick(track.id));
      
      return trackItem;
    },
    
    // Handle track click
    handleTrackClick(trackId) {
      const index = this.state.tracks.findIndex(t => t.id === trackId);
      if (index !== -1) {
        this.state.currentIndex = index;
        this.loadAndPlayCurrentTrack();
        this.updateActiveTrack(trackId);
      }
    },
    
    // Navigate tracks
    playTrack(direction) {
      if (!this.state.tracks.length) return;
      
      const { currentIndex, shuffleMode } = this.state;
      const count = this.state.tracks.length;
      
      let newIndex;
      
      if (shuffleMode && direction === 'next') {
        // Get random track when in shuffle mode and going forward
        newIndex = Math.floor(Math.random() * count);
        // Avoid playing the same track twice in a row
        if (newIndex === currentIndex && count > 1) {
          newIndex = (newIndex + 1) % count;
        }
      } else {
        // Normal sequential navigation
        newIndex = direction === 'next'
          ? (currentIndex + 1) % count
          : (currentIndex - 1 + count) % count;
      }
      
      this.state.currentIndex = newIndex;
      this.loadAndPlayCurrentTrack();
    },
    
    // Get current track object
    getCurrentTrack() {
      const { currentIndex, tracks } = this.state;
      if (currentIndex >= 0 && currentIndex < tracks.length) {
        return tracks[currentIndex];
      }
      return null;
    },
    
    // Load and play the current track
    loadAndPlayCurrentTrack() {
      const track = this.getCurrentTrack();
      if (!track) return;
      
      this.playTrackById(track.id);
      this.updateActiveTrack(track.id);
    },
    
    // Play track by its ID
    playTrackById(trackId) {
      try {
        const track = this.state.tracksById[trackId];
        if (!track) return;
        
        const { genre, title } = track;
        const fileName = encodeURIComponent(title + '.mp3');
        const audioPath = `/assets/static/music/${genre.toLowerCase()}/${fileName}`;
        
        // Update audio player
        this.elements.player.src = audioPath;
        
        // Add a loading indicator instead of immediately changing the title
        this.elements.nowPlaying.textContent = 'Loading...';
        
        // Add a loadeddata event to update the title after the track is loaded
        const handleLoaded = () => {
          this.elements.nowPlaying.textContent = title;
          // Update MediaSession metadata after track is loaded for smoother transitions
          this.updateMediaSession(title);
          this.elements.player.removeEventListener('loadeddata', handleLoaded);
        };
        this.elements.player.addEventListener('loadeddata', handleLoaded);
        
        // Play the track with better error handling
        this.elements.player.play()
          .catch(error => {
            console.error('Error playing audio:', error);
            this.elements.nowPlaying.textContent = `Error playing: ${title}`;
            // Try to play next track after a short delay
            setTimeout(() => this.playTrack('next'), 2000);
          });
      } catch (error) {
        console.error('Error setting up audio:', error);
        this.elements.nowPlaying.textContent = 'Error with track';
        // Try to play next track after a short delay
        setTimeout(() => this.playTrack('next'), 2000);
      }
    },
    
    // Update active track in the playlist
    updateActiveTrack(trackId) {
      // Remove active class from all tracks
      document.querySelectorAll('.track.active').forEach(item => {
        item.classList.remove('active');
      });
      
      // Add active class to current track
      const trackElement = document.querySelector(`.track[data-id="${trackId}"]`);
      if (trackElement) {
        trackElement.classList.add('active');
        
        // Ensure the track is visible by expanding its genre section
        const parentDetails = trackElement.closest('details');
        if (parentDetails && !parentDetails.open) {
          parentDetails.open = true;
        }
        
        // Scroll track into view if needed
        if (!this.isElementInViewport(trackElement)) {
          trackElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
      }
    },
    
    // Check if element is in viewport
    isElementInViewport(el) {
      const rect = el.getBoundingClientRect();
      return (
        rect.top >= 0 &&
        rect.left >= 0 &&
        rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
        rect.right <= (window.innerWidth || document.documentElement.clientWidth)
      );
    },
    
    // Set up media session for lock screen controls
    updateMediaSession(trackTitle) {
      if (!('mediaSession' in navigator)) return;
      
      try {
        // Set track info with the primes.png artwork for all tracks
        navigator.mediaSession.metadata = new MediaMetadata({
          title: trackTitle,
          artwork: [
            { src: window.location.origin + '/assets/static/primes.png', sizes: '512x512', type: 'image/png' }
          ]
        });
        
        // Set up media session actions
        navigator.mediaSession.setActionHandler('previoustrack', () => {
          this.playTrack('prev');
        });
        navigator.mediaSession.setActionHandler('nexttrack', () => {
          this.playTrack('next');
        });
        navigator.mediaSession.setActionHandler('play', () => this.elements.player.play());
        navigator.mediaSession.setActionHandler('pause', () => this.elements.player.pause());
        
        // Add seek handler for compatible browsers
        if ('seekto' in navigator.mediaSession) {
          navigator.mediaSession.setActionHandler('seekto', (details) => {
            if (details.fastSeek && 'fastSeek' in this.elements.player) {
              this.elements.player.fastSeek(details.seekTime);
              return;
            }
            this.elements.player.currentTime = details.seekTime;
          });
        }
        
        this.updatePositionState();
      } catch (error) {
        console.error('Error updating media session:', error);
        // Non-critical error, continue playing
      }
    },
    
    // Update position state for lock screen
    updatePositionState() {
      if (!('mediaSession' in navigator) || !('setPositionState' in navigator.mediaSession)) return;
      
      try {
        const player = this.elements.player;
        if (isNaN(player.duration)) return;
        
        navigator.mediaSession.setPositionState({
          duration: player.duration || 0,
          playbackRate: player.playbackRate || 1,
          position: player.currentTime || 0
        });
      } catch (error) {
        console.error('Error updating position state:', error);
        // Non-critical error, continue playing
      }
    },
    
    // Toggle shuffle mode
    toggleShuffle() {
      this.state.shuffleMode = !this.state.shuffleMode;
      this.updateShuffleButton();
      
      // Auto-start playback if paused and shuffle enabled
      if (this.state.shuffleMode && this.elements.player.paused && this.state.tracks.length > 0) {
        this.playTrack('next');
      }
    },
    
    // Update shuffle button appearance
    updateShuffleButton() {
      const { shuffleButton } = this.elements;
      if (this.state.shuffleMode) {
        shuffleButton.classList.add('active');
        shuffleButton.setAttribute('aria-pressed', 'true');
      } else {
        shuffleButton.classList.remove('active');
        shuffleButton.setAttribute('aria-pressed', 'false');
      }
    }
  };
  
  // Initialize the player
  audioPlayer.init();
  
  // Cleanup on page unload to prevent memory leaks
  window.addEventListener('beforeunload', () => {
    audioPlayer.removeEventListeners();
  });
});
</script>

<style>
  .audio-player {
    position: sticky;
    top: 0;
    font-size: 0.9rem;
    display: flex;
    flex-direction: column;
    align-items: stretch;
    z-index: 10;
  }

  #audio-player {
    width: 100%;
  }
  
  #now-playing {
    font-family: "Atkinson Hyperlegible Mono", "Inconsolata", monospace;
    padding-top: 0.5rem;
    padding-bottom: 0.5rem;
    margin-left: 1rem;
    background-color: #1b1c1d;
  }

  #shuffle-button {
    background-color: #1b1c1d;
    float: right;
    font-family: "Atkinson Hyperlegible Mono", "Inconsolata", monospace;  
    cursor: pointer;
  }
  
  #shuffle-button.active {
    color: #FF530D;
  }

  .track {
    cursor: pointer;
  }
  
  .track:hover {
    text-decoration: underline;
  }
  
  .track.active {
    color: #FF530D;
  }
  
  .track-list {
    margin-bottom: 1rem;
  }
</style>