<!-- Simple Audio Player -->
<div class="audio-player">
  <div id="now-playing"></div>
  <audio id="audio-player" controls></audio>
  <div class="player-controls">
    <button id="prev-button" class="button is-small">⏮</button>
    <button id="shuffle-button" class="button is-small">shuffle</button>
    <button id="next-button" class="button is-small">⏭</button>
  </div>
</div>

<div id="playlist"></div>

<div id="queue"></div>


<script>
document.addEventListener('DOMContentLoaded', () => {
  const player = {
    // DOM Elements
    audio: document.getElementById('audio-player'),
    nowPlaying: document.getElementById('now-playing'),
    playlist: document.getElementById('playlist'),
    shuffleBtn: document.getElementById('shuffle-button'),
    prevBtn: document.getElementById('prev-button'),
    nextBtn: document.getElementById('next-button'),
    
    // State
    tracks: [],
    tracksById: {},
    currentIndex: -1,
    shuffleMode: false,
    
    async init() {
      try {
        const data = await fetch('/assets/data/tracks.json').then(r => r.json());
        this.processData(data);
        this.setupUI(data);
        this.setupEvents();
      } catch (error) {
        console.error('Player error:', error);
        this.playlist.innerHTML = '<p>Failed to load music.</p>';
      }
    },
    
    processData(data) {
      this.tracks = [];
      this.tracksById = {};
      
      Object.entries(data).forEach(([genre, tracks]) => {
        tracks.forEach(track => {
          if (!track || !track.id || !track.title) return;
          
          const trackWithGenre = { genre, id: track.id, title: track.title };
          this.tracks.push(trackWithGenre);
          this.tracksById[track.id] = trackWithGenre;
        });
      });
    },
    
    setupUI(data) {
      this.playlist.innerHTML = '';
      
      Object.entries(data).forEach(([genre, tracks], index) => {
        const details = document.createElement('details');
        details.className = 'genre-section';
        details.open = index === 0; // Open first genre by default
        
        const summary = document.createElement('summary');
        summary.textContent = genre;
        details.appendChild(summary);
        
        const tracksList = document.createElement('ul');
        tracksList.className = 'track-list';
        
        tracks.forEach(track => {
          if (!track || !track.id || !track.title) return;
          
          const li = document.createElement('li');
          li.textContent = track.title;
          li.className = 'track';
          li.dataset.id = track.id;
          li.dataset.genre = genre;
          li.addEventListener('click', () => this.playById(track.id));
          
          tracksList.appendChild(li);
        });
        
        details.appendChild(tracksList);
        this.playlist.appendChild(details);
      });
    },
    
    setupEvents() {
      // Player events
      this.audio.addEventListener('ended', () => this.playNext());
      this.audio.addEventListener('error', () => {
        this.nowPlaying.textContent = 'Error playing track';
        setTimeout(() => this.playNext(), 2000);
      });
      
      // Button events
      this.shuffleBtn.addEventListener('click', () => this.toggleShuffle());
      this.prevBtn.addEventListener('click', () => this.playPrev());
      this.nextBtn.addEventListener('click', () => this.playNext());
      
      // Media session
      if ('mediaSession' in navigator) {
        navigator.mediaSession.setActionHandler('play', () => this.audio.play());
        navigator.mediaSession.setActionHandler('pause', () => this.audio.pause());
        navigator.mediaSession.setActionHandler('previoustrack', () => this.playPrev());
        navigator.mediaSession.setActionHandler('nexttrack', () => this.playNext());
        
        // Listen for play/pause state changes to update MediaSession
        this.audio.addEventListener('play', () => {
          navigator.mediaSession.playbackState = 'playing';
        });
        
        this.audio.addEventListener('pause', () => {
          navigator.mediaSession.playbackState = 'paused';
        });
      }
    },
    
    playById(id) {
      const index = this.tracks.findIndex(t => t.id === id);
      if (index !== -1) {
        this.currentIndex = index;
        this.loadTrack();
      }
    },
    
    loadTrack() {
      const track = this.tracks[this.currentIndex];
      if (!track) return;
      
      // Update active track in UI
      document.querySelectorAll('.track.active').forEach(t => t.classList.remove('active'));
      const trackEl = document.querySelector(`.track[data-id="${track.id}"]`);
      if (trackEl) {
        trackEl.classList.add('active');
        const parentDetails = trackEl.closest('details');
        if (parentDetails) parentDetails.open = true;
      }
      
      // Load and play the track
      const fileName = encodeURIComponent(track.title + '.mp3');
      const path = `/assets/static/music/${track.genre.toLowerCase()}/${fileName}`;
      
      this.nowPlaying.textContent = 'Loading...';
      this.audio.src = path;
      
      // Update media session metadata immediately
      this.updateMediaSession(track);
      
      this.audio.onloadeddata = () => {
        this.nowPlaying.textContent = track.title;
      };
      
      this.audio.play().catch(error => {
        console.error('Play error:', error);
        this.nowPlaying.textContent = `Error: ${track.title}`;
        setTimeout(() => this.playNext(), 2000);
      });
    },
    
    updateMediaSession(track) {
      if ('mediaSession' in navigator) {
        navigator.mediaSession.metadata = new MediaMetadata({
          title: track.title,
          artist: track.genre,
          album: track.genre,
          artwork: [{ src: '/assets/static/mw.jpeg', sizes: '512x512', type: 'image/jpeg' }]
        });
      }
    },
    
    playNext() {
      if (!this.tracks.length) return;
      
      if (this.shuffleMode) {
        // Random track in shuffle mode
        let newIndex = Math.floor(Math.random() * this.tracks.length);
        // Avoid playing the same track twice
        if (newIndex === this.currentIndex && this.tracks.length > 1) {
          newIndex = (newIndex + 1) % this.tracks.length;
        }
        this.currentIndex = newIndex;
      } else {
        // Next track in sequence
        this.currentIndex = (this.currentIndex + 1) % this.tracks.length;
      }
      
      this.loadTrack();
    },
    
    playPrev() {
      if (!this.tracks.length) return;
      this.currentIndex = (this.currentIndex - 1 + this.tracks.length) % this.tracks.length;
      this.loadTrack();
    },
    
    toggleShuffle() {
      this.shuffleMode = !this.shuffleMode;
      this.shuffleBtn.classList.toggle('active', this.shuffleMode);
      this.shuffleBtn.setAttribute('aria-pressed', this.shuffleMode);
      
      // Auto-start playback if paused and shuffle enabled
      if (this.shuffleMode && this.audio.paused && this.tracks.length > 0) {
        this.playNext();
      }
    }
  };
  
  // Initialize the player
  player.init();
});
</script>

<style>
  .audio-player {
    position: sticky;
    top: 0;
    font-size: 0.9rem;
    display: flex;
    flex-direction: column;
    align-items: stretch;
    z-index: 10;
  }

  #audio-player {
    width: 100%;
  }
  
  #now-playing {
    font-family: "Atkinson Hyperlegible Mono", "Inconsolata", monospace;
    padding-top: 0.5rem;
    padding-bottom: 0.5rem;
    margin-left: 1rem;
    background-color: #1b1c1d;
  }

  .player-controls {
    display: flex;
    justify-content: right;
  }
  
  .player-controls button {
    background-color: #1b1c1d;
    font-family: "Atkinson Hyperlegible Mono", "Inconsolata", monospace;  
    cursor: pointer;
    border: none;
  }
  
  #shuffle-button.active {
    color: #FF530D;
  }

  .track {
    cursor: pointer;
  }
  
  .track:hover {
    text-decoration: underline;
  }
  
  .track.active {
    color: #FF530D;
  }
  
  .track-list {
    margin-bottom: 1rem;
  }
</style>