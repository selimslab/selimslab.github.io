<!-- Simple Audio Player -->
<div class="audio-player">
  <div id="now-playing"></div>
  <audio id="audio-player" controls></audio>
  <div class="player-controls">
    <button id="prev-button" aria-label="Previous track">⏮</button>
    <button id="next-button" aria-label="Next track">⏭</button>
  </div>
  <br>
</div>

<div id="playlist"></div>

<div id="queue"></div>


<script>
document.addEventListener('DOMContentLoaded', function() {
  const audioPlayerApp = {
    // DOM Elements
    elements: {
      player: document.getElementById('audio-player'),
      nowPlaying: document.getElementById('now-playing'),
      playlist: document.getElementById('playlist'),
      prevButton: document.getElementById('prev-button'),
      nextButton: document.getElementById('next-button')
    },
    
    // State
    state: {
      currentTrackIndex: -1,
      tracks: [],
      tracksById: {},
      artworks: null
    },
    
    // Initialization
    init: function() {
      this.loadMusicData();
      this.loadArtworkData();
      this.setupEventListeners();
    },
    
    // Event Listeners
    setupEventListeners: function() {
      const { player, prevButton, nextButton } = this.elements;
      
      player.addEventListener('ended', () => this.playTrack('next'));
      player.addEventListener('loadedmetadata', () => this.updatePositionState());
      prevButton.addEventListener('click', () => this.playTrack('prev'));
      nextButton.addEventListener('click', () => this.playTrack('next'));
    },
    
    // Data Loading
    loadMusicData: function() {
      fetch('/assets/data/tracks.json')
        .then(response => response.json())
        .then(data => {
          this.processTrackData(data);
          this.buildPlaylist(data);
        })
        .catch(error => {
          console.error('Error loading music data:', error);
          this.elements.playlist.innerHTML = '<p>Failed to load music.</p>';
        });
    },
    
    processTrackData: function(data) {
      // Flatten all tracks into a single array with genre info
      this.state.tracks = [];
      this.state.tracksById = {};
      
      Object.keys(data).forEach(genre => {
        data[genre].forEach(track => {
          const trackWithGenre = { 
            genre, 
            id: track.id, 
            title: track.title 
          };
          this.state.tracks.push(trackWithGenre);
          this.state.tracksById[track.id] = trackWithGenre;
        });
      });
    },
    
    loadArtworkData: function() {
      fetch('/assets/data/artworks.json')
        .then(response => response.json())
        .then(data => {
          this.state.artworks = data;
        })
        .catch(error => {
          console.error('Error loading artwork data:', error);
        });
    },
    
    // UI Building
    buildPlaylist: function(data) {
      const playlist = this.elements.playlist;
      playlist.innerHTML = '';
      
      Object.keys(data).forEach(genre => {
        const genreElement = this.createGenreSection(genre, data[genre]);
        playlist.appendChild(genreElement);
      });
    },
    
    createGenreSection: function(genre, tracks) {
      const details = document.createElement('details');
      details.className = 'genre-section';
      
      // Open first genre by default
      if (this.elements.playlist.childElementCount === 0) {
        details.open = true;
      }
      
      const summary = document.createElement('summary');
      summary.textContent = genre;
      details.appendChild(summary);
      
      const tracksList = document.createElement('ul');
      tracksList.className = 'track-list';
      
      tracks.forEach(track => {
        const trackItem = this.createTrackItem(genre, track);
        tracksList.appendChild(trackItem);
      });
      
      details.appendChild(tracksList);
      return details;
    },
    
    createTrackItem: function(genre, track) {
      const trackItem = document.createElement('li');
      trackItem.textContent = track.title;
      trackItem.className = 'track';
      trackItem.dataset.genre = genre;
      trackItem.dataset.id = track.id;
      
      trackItem.addEventListener('click', () => {
        // Find index in the flat array of tracks
        const index = this.state.tracks.findIndex(t => t.id === track.id);
        if (index !== -1) {
          this.state.currentTrackIndex = index;
          this.loadAndPlayCurrentTrack();
          this.updateActiveTrackInDOM(track.id);
        }
      });
      
      return trackItem;
    },
    
    // Track Navigation
    playTrack: function(direction) {
      if (this.state.tracks.length === 0) return;
      
      let newIndex;
      const { currentTrackIndex } = this.state;
      const tracksLength = this.state.tracks.length;
      
      if (direction === 'next') {
        newIndex = (currentTrackIndex + 1) % tracksLength;
      } else {
        newIndex = (currentTrackIndex - 1 + tracksLength) % tracksLength;
      }
      
      this.state.currentTrackIndex = newIndex;
      this.loadAndPlayCurrentTrack();
      
      // Update active class in DOM
      const currentTrack = this.state.tracks[newIndex];
      this.updateActiveTrackInDOM(currentTrack.id);
    },
    
    loadAndPlayCurrentTrack: function() {
      const currentIndex = this.state.currentTrackIndex;
      if (currentIndex < 0 || currentIndex >= this.state.tracks.length) return;
      
      const track = this.state.tracks[currentIndex];
      this.playTrackById(track.id);
    },
    
    playTrackById: function(trackId) {
      try {
        const trackData = this.state.tracksById[trackId];
        if (!trackData) return;
        
        const genre = trackData.genre;
        const title = trackData.title;
        const fileName = encodeURIComponent(title + '.mp3');
        const audioPath = `/assets/static/music/${genre.toLowerCase()}/${fileName}`;
        
        // Update audio source
        this.elements.player.src = audioPath;
        this.elements.nowPlaying.textContent = title;
        
        // Play the track and ensure media session is updated
        const playPromise = this.elements.player.play();
        
        if (playPromise !== undefined) {
          playPromise
            .then(() => {
              // Playback started successfully - update media session after metadata is loaded
              this.updateMediaSession(title);
            })
            .catch(e => {
              console.error('Error playing audio:', e);
              this.elements.nowPlaying.textContent = 'Error playing: ' + title;
            });
        }
      } catch (error) {
        console.error('Error setting up audio:', error);
        this.elements.nowPlaying.textContent = 'Error with track';
      }
    },
    
    updateActiveTrackInDOM: function(trackId) {
      document.querySelectorAll('.track.active').forEach(item => {
        item.classList.remove('active');
      });
      
      const trackElement = document.querySelector(`.track[data-id="${trackId}"]`);
      if (trackElement) {
        trackElement.classList.add('active');
      }
    },
    
    // Get random artwork
    getRandomArtwork: function() {
      if (!this.state.artworks || this.state.artworks.length === 0) {
        return null;
      }
      const randomIndex = Math.floor(Math.random() * this.state.artworks.length);
      return this.state.artworks[randomIndex];
    },
    
    updateMediaSession: function(trackTitle) {
      if ('mediaSession' in navigator) {
        const artwork = this.getRandomArtwork();
        const artworkUrl = artwork ? artwork.path : null;
        
        navigator.mediaSession.metadata = new MediaMetadata({
          title: trackTitle,
          artwork: artworkUrl ? [
            { src: window.location.origin + artworkUrl, sizes: '512x512', type: 'image/jpeg' }
          ] : []
        });
        
        // Add media session action handlers for lock screen controls
        navigator.mediaSession.setActionHandler('previoustrack', () => this.playTrack('prev'));
        navigator.mediaSession.setActionHandler('nexttrack', () => this.playTrack('next'));
        navigator.mediaSession.setActionHandler('seekto', (details) => {
          if (details.fastSeek && 'fastSeek' in this.elements.player) {
            this.elements.player.fastSeek(details.seekTime);
            return;
          }
          this.elements.player.currentTime = details.seekTime;
        });
        
        // Update playback state for lock screen
        navigator.mediaSession.setActionHandler('play', () => this.elements.player.play());
        navigator.mediaSession.setActionHandler('pause', () => this.elements.player.pause());

        // Regularly update position state
        this.updatePositionState();
        this.elements.player.addEventListener('timeupdate', () => this.updatePositionState());
      }
    },
    
    updatePositionState: function() {
      if ('mediaSession' in navigator && 'setPositionState' in navigator.mediaSession) {
        const player = this.elements.player;
        
        navigator.mediaSession.setPositionState({
          duration: player.duration || 0,
          playbackRate: player.playbackRate || 1,
          position: player.currentTime || 0
        });
      }
    }
  };
  
  audioPlayerApp.init();
});
</script>

<style>
  .audio-player {
    position: sticky;
    top: 0;
    font-size: 0.9rem;
  }
  
  #audio-player {
    width: 100%;
  }
  
  #now-playing {
    font-family: "Atkinson Hyperlegible Mono", "Inconsolata", monospace;
    padding-top: 0.5rem;
    padding-bottom: 0.5rem;
    margin-left: 1rem;
    background-color: #1b1c1d;
  }

  .player-controls {
    display: flex;
    justify-content: right;
    gap: 10px;
    margin-top: 5px;
  }

  .player-controls button {
    padding-right: 0.5rem;
    font-size: 1.2rem;
    background-color: none;
    border: none; 
  }


  .track {
    cursor: pointer;
  }

  .track:hover {
    color: #ffc800;
  }
  
  .track.active {
    color: #FF530D;
  }
</style>