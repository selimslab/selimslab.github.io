<div id="graph-container"></div>

<script src="//unpkg.com/three"></script>
<script src="//unpkg.com/three-spritetext"></script>
<script src="//unpkg.com/3d-force-graph"></script>

<script>

  async function getGraohData(id=null){
    const gData = await fetch("/assets/data/graph.json").then((response) =>
      response.json()
    );

    if (id !== null){
        node = gData["nodes"][id]
        links =  node["links"]
        if (links.length == 0){
          return 
        }
        gData["links"] = links

        nodes  =  [ node ]
        for (const n of node["neighbors"]){
            nodes.push(gData["nodes"][n])
        }
        gData["nodes"] = nodes
    } else {
      gData["nodes"] = Object.values(gData["nodes"])
    }

    return gData
  }

  function drawGraph(id=null){

    (async () => {

    const gData = getGraohData(id)
    const highlightNodes = new Set();
    const highlightLinks = new Set();
    let hoverNode = null;

    const container = document.getElementById("graph-container");

    const g = ForceGraph3D();

    g(container)
      .graphData(gData)
      .nodeLabel("name")
      .nodeAutoColorBy('group')
      .linkWidth((link) => (highlightLinks.has(link) ? 1 : 0.1))
      .nodeVisibility(node => node.neighbors.length != 0)
      .nodeThreeObject(node => {
          const sprite = new SpriteText(node.name);
          sprite.material.depthWrite = false; // make sprite background transparent
          sprite.color = node.color;
          sprite.textHeight = 8;
          return sprite;
        });
        // .onNodeHover(node => {
        //   // no state change
        //   if ((!node && !highlightNodes.size) || (node && hoverNode === node)) return;

        //   highlightNodes.clear();
        //   highlightLinks.clear();
        //   if (node) {
        //     highlightNodes.add(node);
        //     node.neighbors.forEach(neighbor => highlightNodes.add(neighbor));
        //     node.links.forEach(link => highlightLinks.add(link));
        //   }

        //   hoverNode = node || null;

        //   updateHighlight();
        // })
        // .onLinkHover(link => {
        //   highlightNodes.clear();
        //   highlightLinks.clear();

        //   if (link) {
        //     highlightLinks.add(link);
        //     highlightNodes.add(link.source);
        //     highlightNodes.add(link.target);
        //   }

        //   updateHighlight();
        // });

    g.d3Force("center", null);

    // Spread nodes a little wider
    g.d3Force('charge').strength(-150);

    // function updateHighlight() {
    //   // trigger update of highlighted objects in scene
    //   g
    //     .nodeColor(g.nodeColor())
    //     .linkWidth(g.linkWidth())
    //     .linkDirectionalParticles(g.linkDirectionalParticles());
    // }

  })();



  }


</script>
