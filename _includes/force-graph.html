<div id="graph-container"></div>

<script src="//unpkg.com/force-graph"></script>
<script src="//unpkg.com/3d-force-graph"></script>

<script>
  function drawGraph(id=null){

    (async () => {
    const gData = await fetch("/assets/data/graph.json").then((response) =>
      response.json()
    );

    if (id !== null){
        node = gData["nodes"][id]
        links =  node["links"]
        if (links.length == 0){
          return 
        }
        gData["links"] = links

        nodes  =  [ node ]
        for (const n of node["neighbors"]){
            nodes.push(gData["nodes"][n])
        }
        gData["nodes"] = nodes
    } else {
      gData["nodes"] = Object.values(gData["nodes"])
    }

    const highlightNodes = new Set();
    const highlightLinks = new Set();
    let hoverNode = null;

    const container = document.getElementById("graph-container");

    const g = ForceGraph();
    g(container)
      .graphData(gData)
      .nodeLabel("name")
      .minZoom(1)
      .maxZoom(5)
      .linkColor((link) => (highlightLinks.has(link) ?  "#FF530D" : "#568692"))
      .linkWidth((link) => (highlightLinks.has(link) ? 1 : 0.1))
      .onNodeHover((node) => {
        highlightNodes.clear();
        highlightLinks.clear();
        if (node) {
          highlightNodes.add(node.id);
          node.neighbors.forEach((neighbor) => highlightNodes.add(neighbor));
          node.links.forEach((link) => highlightLinks.add(link));
        }

        hoverNode = node || null;
      })
      .onLinkHover((link) => {
        highlightNodes.clear();
        highlightLinks.clear();

        if (link) {
          highlightLinks.add(link);
          highlightNodes.add(link.source.id);
          highlightNodes.add(link.target.id);
        }
      })
      .autoPauseRedraw(false) // keep redrawing after engine has stopped
      .nodeCanvasObject((node, ctx, globalScale) => {
        const label = node.name;

        if (id == null && g.zoom() < 1.618) {
            return 
        } 

        const fontSize = 12 / globalScale;
        ctx.font = `${fontSize}px Sans-Serif`;
        const textWidth = ctx.measureText(label).width;
        const bckgDimensions = [textWidth, fontSize].map(
          (n) => n + fontSize * 0.5
        ); // some padding

        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        let color = "#2398ff";
        if (node.type == "tag") {
          color = "orange";
        }
        if (highlightNodes.has(node.id)) {
          color = "#FF530D";
        }

        ctx.fillStyle = color;
        ctx.fillText(label, node.x, node.y);
        
        node.__bckgDimensions = bckgDimensions; // to re-use in nodePointerAreaPaint
      })
      .nodePointerAreaPaint((node, color, ctx) => {
        ctx.fillStyle = color;
        const bckgDimensions = node.__bckgDimensions;
        bckgDimensions &&
          ctx.fillRect(
            node.x - bckgDimensions[0] / 2,
            node.y - bckgDimensions[1] / 2,
            ...bckgDimensions
          );
      })
      .onNodeDragEnd(node => {
        node.fx = node.x;
        node.fy = node.y;
      });

    g.d3Force("center", null);
    // fit to canvas when engine stops
    g.onEngineStop(() => g.zoomToFit());

  })();

  }

    // const g = ForceGraph();
    // g(container)
    //     .nodeColor(node => node.type === "tag" ? '#FF530D' : '#2398ff')
    //     .linkColor(link => "#568692")
    //     .linkWidth(0.3)
    //     .nodeRelSize(2)
    //     .graphData(gData)
    //     .nodeLabel("name")
    //     .onNodeClick(node => {
    //     // Center/zoom on node
    //     g.centerAt(node.x, node.y, 1000);
    //     g.zoom(3, 2000);
    //   })
    //   .minZoom(1)
    //   .maxZoom(3)

    //   g.d3Force('center', null);

    // })();

    // const g = ForceGraph();
    // g(container)
    //   .graphData(gData)
    //   .nodeColor((node) => (node.type === "tag" ? "#FF530D" : "#2398ff"))
    //   .linkColor((link) => "#568692")
    //   // .nodeRelSize(NODE_R)
    //   .nodeLabel("name")
    //   .minZoom(1)
    //   .maxZoom(3)
    //   .onNodeHover((node) => {
    //     highlightNodes.clear();
    //     highlightLinks.clear();
    //     if (node) {
    //       highlightNodes.add(node.id);
    //       node.neighbors.forEach((neighbor) => highlightNodes.add(neighbor));
    //       node.links.forEach((link) => highlightLinks.add(link));
    //     }

    //     hoverNode = node || null;
    //   })
    //   .onLinkHover((link) => {
    //     highlightNodes.clear();
    //     highlightLinks.clear();

    //     if (link) {
    //       highlightLinks.add(link);
    //       highlightNodes.add(link.source);
    //       highlightNodes.add(link.target);
    //     }
    //   })
    //   .autoPauseRedraw(false) // keep redrawing after engine has stopped
    //   .linkWidth((link) => (highlightLinks.has(link) ? 3 : 0.3))
    //   .nodeCanvasObjectMode((node) =>
    //     highlightNodes.has(node.id) ? "before" : undefined
    //   )
    //   .nodeCanvasObject((node, ctx, globalScale) => {
    //     // add ring just for highlighted nodes
    //     const R = NODE_R * Math.sqrt(node.val)

    //     // ctx.beginPath();
    //     // ctx.arc(
    //     //   node.x,
    //     //   node.y,
    //     //   R * 1.2,
    //     //   0,
    //     //   2 * Math.PI,
    //     //   false
    //     // );
    //     const label = node.name;
    //     const fontSize = 12/globalScale;
    //     ctx.font = `${fontSize}px Sans-Serif`;
    //     const textWidth = ctx.measureText(label).width;
    //     const bckgDimensions = [textWidth, fontSize].map(n => n + fontSize * 0.2); // some padding

    //     ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    //     ctx.fillRect(node.x - bckgDimensions[0] / 2, node.y - bckgDimensions[1] / 2, ...bckgDimensions);

    //     ctx.fillStyle = highlightNodes.has(node.id) ? "yellow" : null;
    //     ctx.textAlign = 'center';
    //     ctx.textBaseline = 'middle';
    //     ctx.fillStyle = node.color;
    //     ctx.fillText(node.name, node.x-R*1.4, node.y+R*1.4);
    //     // ctx.fill();

    //     node.__bckgDimensions = bckgDimensions; // to re-use in nodePointerAreaPaint
    //     })
    //     .nodePointerAreaPaint((node, color, ctx) => {
    //       ctx.fillStyle = color;
    //       const bckgDimensions = node.__bckgDimensions;
    //       bckgDimensions && ctx.fillRect(node.x - bckgDimensions[0] / 2, node.y - bckgDimensions[1] / 2, ...bckgDimensions);
    //     });

</script>
